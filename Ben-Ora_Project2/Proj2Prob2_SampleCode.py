import numpy as np
import matplotlib.pyplot as plt
import math
import pandas as pd

def get_velocity(strength, xs, ys, X, Y):
    """
    Returns the velocity field generated by a source/sink.
    
    Parameters
    ----------
    strength: float
        Strength of the source/sink.
    xs: float
        x-coordinate of the source (or sink).
    ys: float
        y-coordinate of the source (or sink).
    X: 2D Numpy array of floats
        x-coordinate of the mesh points.
    Y: 2D Numpy array of floats
        y-coordinate of the mesh points.
    
    Returns
    -------
    u: 2D Numpy array of floats
        x-component of the velocity vector field.
    v: 2D Numpy array of floats
        y-component of the velocity vector field.
    """
    u = strength/(2*np.pi)*(X-xs)/((X-xs)**2+(Y-ys)**2)
    v = strength/(2*np.pi)*(Y-ys)/((X-xs)**2+(Y-ys)**2)
    
    return u, v


def get_stream_function(strength, xs, ys, X, Y):
    """
    Returns the stream-function generated by a source/sink.
    
    Parameters
    ----------
    strength: float
        Strength of the source/sink.
    xs: float
        x-coordinate of the source (or sink).
    ys: float
        y-coordinate of the source (or sink).
    X: 2D Numpy array of floats
        x-coordinate of the mesh points.
    Y: 2D Numpy array of floats
        y-coordinate of the mesh points.
    
    Returns
    -------
    psi: 2D Numpy array of floats
        The stream-function.
    """
    psi = strength/(2*np.pi)*np.arctan2((Y-ys), (X-xs))
    
    return psi


# You can begin by choosing your symmetric airfoil geometry. You can plot it using methods we've used in past
# projects, or you can choose to simply find it online as we did in Project 0.


# 2.1 - Create a Meshgrid - See Lorena Barba's AeroPython Lesson02
N =                             # Number of points in each direction
                                # x-direction boundaries
                                # y-direction boundaries
                                # 1D-array for x   
                                # 1D-array for y                        
X, Y =

# 2.2 - Create an array of source/sink strengths, as well as their locations. 
# One method to doing this is to create an individual source/sink strength along with its x location 
# and y location on our grid, and then use superposition (as in Problem 1) to add all our desired 
# sources and sinks together. However, it might be simpler to use arrays to hold all of the strengths,
# and all of our locations/coordinates within our grids.

# Using this method, each index of the below arrays would correspond to a specific source or sink.

# Remember, in order to have a closed contour for our dividing streamline, the sum of all our
# sources and sinks must be equal to 0; You might choose to include a statement that checks the sum
# of your strength vector
strength = np.array([])
print()

x_sourceLoc = np.array([])
y_sourceLoc = np.array([])

# 2.3 Using superposition.
# Here, we should create all of our sources/sinks, and calculate their individual contributions.

# First create your uniform flow (Same as Problem 1)

U_Total = 
V_Total =
psi_Total =

# Now, start calculating contributions. The code below is used to create a SINGLE source/sink based on
# the value of strength. There is an easier way to do this multiple times while changing the value of 
# the inputs.... (Use a for loop)
U , V = get_velocity(strength, x_sourceLoc, y_sourceLoc, X, Y)

psi = get_stream_function(strength, x_sourceLoc, y_sourceLoc, X, Y)

# This is where you would start adding up contributions.
U_Total = 
V_Total =
psi_Total = 

# 2.4 Plotting
# The most simple way to get this plot is to use the following line of code. You will need to add the
# rest of the formatting, extra variables, and labels as you need.

plt.streamplot(X,Y,U_Total,V_Total,density=2,linewidth=1,arrowsize=1,arrowstyle='->')
CS = plt.contour(X,Y,psi_Total,levels=[0.0],colors='k',linewidths=2,linestyles='solid')
CS.collections[0].set_label('Div. Streamline')


# 2.5 Error Calculation
# Here, you will follow this procedure to "extract" the coordinates of the dividing streamline. You will
# need to do this in order to compare these coordinates with your chosen airfoil coordinates.
paths = CS.collections[0].get_paths()
quiet = False
ipath = 0
tol=10e-3

if not quiet:
        if len(paths) < 2:
            print('Only one dividing streamline path')
        else:
            print('Multiple paths in dividing streamline, select the best one')
path =  paths[ipath]       
n = len(path.vertices[:, 0])
size = (len(path.vertices[:, 0]), 2)
xy_contour = np.zeros(size)
xy_contour[:,0] = path.vertices[:, 0]
xy_contour[:,1] = path.vertices[:, 1]
x_div, y_div = xy_contour[:,0], xy_contour[:,1]

# Make extracted coordinates into Pandas DataFrame for easy sorting
# Remove values that are unnecessary
df = pd.DataFrame({'x':x_div, 'y':y_div})
#Extract values that are within the specified chord limits
df = df[(df.x > 0.) & (df.x < 3)]
#Extract values that are not on the chord line
df = df[(df.y < -tol) | (df.y > tol)]
df['y'] = abs(df['y'])
df = df.sort_values(['x', 'y'], ascending=[True, True])
df = df.drop_duplicates(subset='x', keep="last")

plt.figure(figsize=[6,6])
plt.plot(x_div, y_div, label='Extracted Contour')
plt.plot(df['x'], df['y'], label='3/4 Approximation')
plt.axis('equal')
plt.legend(loc='best')
plt.show()

# From here, use df['x'], df['y'], to compare to your airfoil coordinates and quanitfy error.
print(df['x'])
print(df['y'])